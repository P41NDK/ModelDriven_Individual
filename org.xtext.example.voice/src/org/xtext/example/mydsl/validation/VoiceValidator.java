/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.validation;

import java.util.HashSet;

import org.eclipse.xtext.validation.Check;
import org.xtext.example.mydsl.voice.Agent;
import org.xtext.example.mydsl.voice.Declaration;
import org.xtext.example.mydsl.voice.Intent;
import org.xtext.example.mydsl.voice.Model;
import org.xtext.example.mydsl.voice.Question;
import org.xtext.example.mydsl.voice.TrainingRef;
import org.xtext.example.mydsl.voice.VoicePackage;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class VoiceValidator extends AbstractVoiceValidator {
	protected static String ISSUE_CODE_PREFIX = "org.example.intents.";
	
	public static String HIERARCHY_CYCLE =
			ISSUE_CODE_PREFIX + "HierarchyCycle";
	@Check
	public void checkNoCycleInIntentHierarchy(Model model) {
		HashSet<Intent> visitedIntents = new HashSet<Intent>();
		for(Agent agent : model.getAgent()) {
			if(agent instanceof Intent) {
				Intent intent = (Intent) agent;
				if (intent.getZuper() == null) {
					return ; // nothing to check
				}
				visitedIntents.add(intent);
				Intent current = intent.getZuper();
				while (current != null) {
				if (visitedIntents.contains(current)) {
					error("cycle in hierarchy of intent '"+current.getName()+"'", VoicePackage.Literals.MODEL__AGENT, HIERARCHY_CYCLE, current.getZuper().getName());
				return ;
				}
				visitedIntents.add(current);
				current = current.getZuper();
				}
			}
		}
	}
	@Check
	public void checkQuestion(Question question) {
		if(question.getPrompt().isEmpty()) {
			warning("Prompt should not be empty", VoicePackage.Literals.QUESTION__PROMPT);
		}
	}
	@Check
	public void checkDeclaration(Declaration declaration) {
		if(declaration.getTrainingstring().isEmpty()){
			warning("Trainingstring should not be empty", VoicePackage.Literals.DECLARATION__TRAININGSTRING);
		}
	}
	@Check
	public void checkFeatureNameIsUnique(Question question) {
	    Intent superIntent = ((Intent) question.eContainer()).getZuper();
	    while (superIntent != null) {
	        for (Question other : superIntent.getQuestion()) {
	            if (question.getPrompt().equals(other.getPrompt())) {
	                error("Prompt must be unique", VoicePackage.Literals.QUESTION__PROMPT);
	                return;
	            }
	        }
	        superIntent = superIntent.getZuper();
	    }
	}
	@Check
	public void checkForTraining(Question question){
		Intent intent = ((Intent) question.eContainer());
		Boolean exists = false;
		Object questionTest = question.getQuestionEntity().getWithEntity().getSysvar() != null? question.getQuestionEntity().getWithEntity().getSysvar() : question.getQuestionEntity().getWithEntity().getEntity();
		for(TrainingRef trainingRef : intent.getTraining().getTrainingref()) {
			if(trainingRef.getDeclarations().getReference().getSysvar().equals(questionTest)) {
				exists = true;
				break;
			}
			else if(trainingRef.getDeclarations().getReference().getEntity().equals(questionTest)){
				exists = true;
				break;
			}
		}
		if(!exists) {
			error("You need to write training for this", VoicePackage.Literals.QUESTION__QUESTION_ENTITY);
		}
	}
	
	
}
	
